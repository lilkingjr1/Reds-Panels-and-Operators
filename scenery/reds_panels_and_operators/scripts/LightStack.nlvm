// Light Stack NL2 Script
// David Wolfe (Red-Thirten)
// 6/7/2020
// Initializes the light stack's lights and animates the pilot lights during run time, based on user settings.
// Licensed under GNU GPLv3 - See LICENSE for more details.

import com.nolimitscoaster.*;
import nlvm.util.Vector;
import nlvm.math3d.Vector3f;

public class LightStack extends Script{
	private static final String SCRIPT_NAME = "LightStack";							// Script name for debugging
	private static final String ELEMENT_PREFIX = "light";							// Prefix of the light elements in the model
	private static final String PARAMETER_PREFIX = "light";							// Prefix of the static light parameters in the SCO
	private static final Vector3f SPEAKER_LOCATION = new Vector3f(0.f, 0.45f, 0.f);	// Speaker position in the model/SCO, relative to the origin
	
	private static final String[] MODES = { // Possible mode parameters
		"static",
		"dispatch_mode",
		"block_mode"
	};
	private static final int[] PLATFORM_COASTERS = {2, 4, 6, 14, 21, 22, 24};		// All platform coaster IDs in NL2, as of this file's creation date
	
	private Vector lightElements;
	
    private Coaster coaster;
    private Block block;
    private Section section;
	
    private StaticSound soundEmergency;
	
	private int mode = 0;
	private bool coasterHasPlatform, soundPlayed;
	
	
	public bool onInit(){ // On initialization of Play simulation
		SceneObject sco = getScoFromParentEntity(); // Get and assign local sco
		lightElements = getLightElementsOnSco(sco); // Get and assign light elements
		mode = getModeFromScoParams(sco);
		
		if (mode == 0){
			handleStaticMode(sco);
			return true;
		}
		else{ // If not static mode
			getEmergencySoundFromParams(sco);
			block = sco.getBlockParameter("block");
			if (block != null){ // Get ride details based on block parameter
				coaster = block.getCoaster();
				if (coaster.isScriptedOperationMode()){
					System.err.println(SCRIPT_NAME + ": Sorry! Non-static modes do not support Scripted Operation Mode rides at this time.");
					return false;
				}
				section = block.getSection();
				coasterHasPlatform = isCoasterWithPlatform(coaster);
				return true;
			}
			else{
				if (!sco.getName().equals("")){
					System.err.println(sco.getName() + ": Block parameter required for any non-static mode.");
				}
				else{
					System.err.println(SCRIPT_NAME + ": Block parameter required for any non-static mode.");
				}
				return false;
			}
		}
	}
	
	private SceneObject getScoFromParentEntity(){ // Returns the SceneObject via the parent entity ID with error handling
        SceneObject sco = sim.getSceneObjectForEntityId(getParentEntityId());
        if (sco == null){
            System.err.println(SCRIPT_NAME + ": This script only works with NL2 scene objects");
        }
        return sco;
    }
	
	private Vector getLightElementsOnSco(SceneObject sco){ // Returns a dynamic array of all the light elements in the model/SCO (can be any amount)
        int elementCount = 0;
        Vector elements = new Vector();
		
        SceneObjectElement element = sco.getElementForName(ELEMENT_PREFIX + elementCount); // Check if at least one element exists using the provided prefix
        if (element == null){
            System.err.println(SCRIPT_NAME + ": Wrong 3d model loaded (Cannot find \"" + ELEMENT_PREFIX + elementCount + "\" element)");
        }

        while (element != null){ // Add all the elements to the array
            elementCount++;
            elements.addElement(element);
            element = sco.getElementForName(ELEMENT_PREFIX + elementCount);
        }

        return elements;
    }
	
	private int getModeFromScoParams(SceneObject sco){ // Returns the mode ID, based on the first MODES-based parameter to be found true
		Boolean curBool = null;
		
		for (int i = 0; i < MODES.length; i++){ // Traverse the MODES array
			curBool = sco.getBooleanParameter( MODES[i] ); // Get the corresponding parameter
			if (curBool != null && curBool.boolValue()){ // Check if it exists, then if it is positive
				return i;
			}
		}
		return 0; // Default to static mode if no mode selection found
	}
	
	private bool isCoasterWithPlatform(Coaster coaster){ // Returns if the given coaster has a platform station, based on the master PLATFORM_COASTERS list
		int coasterID = coaster.getCoasterStyleId();
		for (int i = 0; i < PLATFORM_COASTERS.length; i++){
			if (PLATFORM_COASTERS[i] == coasterID) return true;
		}
		return false;
	}
	
	private void getEmergencySoundFromParams(SceneObject sco){ // Gets and initializes the E-Stop sound from the parameters, if it exists
		// Assign new StaticSound, with given sound file from parameters, and set to mono mode
		soundEmergency = StaticSound.loadFromResource(sco.getResourcePathParameter("estop_sound"), StaticSound.FLAG_MIXDOWN_MONO);
		if (soundEmergency == null) return; // Return if no sound set
		
		Vector3f speakerLocation = sco.getTranslation(); // Get SCO origin posision
		speakerLocation.add(SPEAKER_LOCATION); // Add the speaker location translation
		soundEmergency.setPosition(speakerLocation); // Set the sound position to this new location
		soundEmergency.setDopplerMode(false);
		soundPlayed = false;
	}
	
	private void handleStaticMode(SceneObject sco){
		for (int i = 0; i < lightElements.size(); i++){ // Set all the lights' states, based on static parameters
			switch (sco.getIntegerParameter(PARAMETER_PREFIX + i).intValue()){
				case 1:
					((SceneObjectElement) lightElements.elementAt(i)).setTextureAnimationIndex(1);
					break;
				case 2:
					((SceneObjectElement) lightElements.elementAt(i)).setTextureAnimationIndex(-1);
					break;
				default:
					((SceneObjectElement) lightElements.elementAt(i)).setTextureAnimationIndex(0);
			}
		}
	}
	
	private void handleDispatchMode(){
		if (coaster.isEmergencyStop()){ // Top light on when E-Stopped
			((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
			((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
			((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(1);
			
			if (!soundPlayed && soundEmergency != null){ // Play E-Stop sound once, if set
				soundEmergency.play();
				soundPlayed = true;
			}
		}
		else{
			switch (block.getNormalModeState(Block.PROTOCOL_V1)){
				case Block.STATE_IN_STATION: // Handle in-station state
					if (section.isStationWaitingForClearBlock()){ // Blink top light if waiting for clear block
						((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(-1);
					}
					else{
						((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(0);
					}
					
					if (section.getTrainOnSection().getHarnessState() != 0.f || section.getStationGateState() != 0.f){ // Middle light on if harness or gates are not closed
						((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
						((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(1);
					}
					else if (coasterHasPlatform && section.getStationPlatformState() != 0.f){ // Blink middle light if the station has a platform that needs to be lowered
						((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
						((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(-1);
					}
					else{ // Blink bottom light when ready to dispatch
						((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(-1);
						((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
					}
					break;
				case Block.STATE_OCCUPIED: // Train is dispatching -- Bottom light on
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(1);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(0);
					break;
				case Block.STATE_FULL_MANUAL_MODE: // All lights blink in full manual mode
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(-1);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(-1);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(-1);
					break;
				default: // Default is all lights off
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(0);
			}
			
			if (soundPlayed){ // Reset E-Stop sound when not in E-Stop
				soundPlayed = false;
			}
		}
	}
	
	private void handleBlockMode(){
		if (coaster.isEmergencyStop()){ // Top light on when E-Stopped
			((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
			((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
			((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(1);
			
			if (!soundPlayed && soundEmergency != null){ // Play E-Stop sound once, if set
				soundEmergency.play();
				soundPlayed = true;
			}
		}
		else{
			switch (block.getNormalModeState(Block.PROTOCOL_V1)){ // Handle block states
				case Block.STATE_OCCUPIED:
				case Block.STATE_IN_STATION:
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(1);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(0);
					break;
				case Block.STATE_APPROACHING_FWD:
				case Block.STATE_APPROACHING_BWD:
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(-1);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(0);
					break;
				case Block.STATE_IDLE:
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(1);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(0);
					break;
				default:
					((SceneObjectElement) lightElements.elementAt(0)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(1)).setTextureAnimationIndex(0);
					((SceneObjectElement) lightElements.elementAt(2)).setTextureAnimationIndex(-1);
			}
			
			if (soundPlayed){ // Reset E-Stop sound when not in E-Stop
				soundPlayed = false;
			}
		}
	}

	public void onNextFrame(float tick){
		switch (mode){
			case 0:
				break;
			case 1:
				handleDispatchMode();
				break;
			case 2:
				handleBlockMode();
				break;
			default:
		}
	}
}