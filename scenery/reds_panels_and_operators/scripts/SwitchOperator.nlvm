/**
	Switch NL2 Script
	David Wolfe (Red-Thirten)
	03/03/2023
	Animates the switch during run time, based on user settings.
	Licensed under GNU GPLv3 - See LICENSE for more details.
*/

import com.nolimitscoaster.Script;
import com.nolimitscoaster.SceneObject;
import com.nolimitscoaster.SceneObjectElement;
import com.nolimitscoaster.Coaster;
import com.nolimitscoaster.Block;
import com.nolimitscoaster.Section;
import com.nolimitscoaster.SpecialTrack;
import nlvm.lang.Math;

import obj.OperatorSwitch;
import util.SpecialTrackModule;

public class SwitchOperator extends Script{
	protected String SCRIPT_NAME = "SwitchOperator";	// Script name for debugging
	protected String SWITCH_ELEMENT_NAME = "switch";	// Name of the switch element in the SCO/model
	protected String PLACARD_ELEMENT_NAME = "placard";	// Name of the placard element in the SCO/model
	protected float SWITCH_TRAVEL_TIME = 0.4f;			// Time, in seconds, for the switch to travel ("speed")
	
	private static final String[] MODES = { // Possible mode parameters
		"static",
		"restraints",
		"gates",
		"platform",
		"trains",
		"transports",
		"special_track_mode",
		"maintenance_mode",
		"lights",
		"manual_lift_jog"
	};
	private static final int[] PLATFORM_COASTERS = {2, 4, 6, 14, 21, 22, 24}; // All platform coaster IDs in NL2, as of this file's creation date
	private static final float SUN_ELEVATION_LIMIT = (float)Math.toRadians(18.0); // 18 degrees is the default sun angle limit for lights to turn on and off
	
	protected Coaster coaster;
	private Block block;
	private Section section;
	private SpecialTrack specialTrack;
	
	protected OperatorSwitch operatorSwitch;
	private SpecialTrackModule specialTrackModule;
	
	protected int mode = 0;
	private int trainsLashedToTrack;
	private int TRAIN_COUNT; // Semi-static (set only once during init)
	private float binaryState = 0.f; // Helps determine if a "binary" state starts to change to the other value (ie. gates start to close, vice-versa, etc)
	private bool coasterHasPlatform;
	
	public bool onInit(){ // On initialization of Play simulation
		// Get and assign local sco
		SceneObject sco = getScoFromParentEntity();

		// Hide placard if configured
		if ( sco.getBooleanParameter("hide_placard").boolValue() ){
			getElementOnScoForName(sco, PLACARD_ELEMENT_NAME).setVisible(false);
		}
		
		if (sco.getSpecialTrackParameter("special_track") != null){ // If set to attach to special track, set up the module object for it
			specialTrackModule = new SpecialTrackModule(sco);
		}
		
		// Get configured mode
		mode = getModeFromScoParams(sco);
		if (mode != 0){ // If not static mode
			block = sco.getBlockParameter("block");
			if (block != null){ // Get ride details based on block parameter
				coaster = block.getCoaster();
				if (coaster.isScriptedOperationMode()){
					System.err.println(SCRIPT_NAME + ": Sorry! Non-static modes do not support Scripted Operation Mode rides at this time.");
					return false;
				}
				section = block.getSection();
			}
			else{
				if (!sco.getName().equals("")){
					System.err.println(sco.getName() + ": Block parameter required for any non-static mode.");
				}
				else{
					System.err.println(SCRIPT_NAME + ": Block parameter required for any non-static mode.");
				}
				return false;
			}
		}
		
		// Create OperatorSwitch object
		createSwitchObject(sco);
		
		// Setup configured mode
		switch (mode){
			case 1: // Restraints
				if (block.getNormalModeState(Block.PROTOCOL_V1) == Block.STATE_IN_STATION){ // Set initial switch state based on initial train harness state
					operatorSwitch.setSwitchState((int) section.getTrainOnSection().getHarnessState());
				}
				break;
			case 2: // Gates
				operatorSwitch.setSwitchState(1 - (int) section.getStationGateState()); // Set initial switch state based on initial station gates state
				break;
			case 3: // Platform
				coasterHasPlatform = isCoasterWithPlatform(coaster); // Check if the coaster has a platform
				if (coasterHasPlatform) operatorSwitch.setSwitchState(1 - (int) section.getStationPlatformState()); // Set initial switch state based on initial station platform state
				break;
			case 4: // Trains on Track
				TRAIN_COUNT = coaster.getTrainCount(); // Set static train count
				break;
			case 5: // Transports
			case 6: // Special Track
			case 9: // Manual Lift Jog
				operatorSwitch.setSwitchState(1);
				break;
		}
		
		return true; // Everything's just dandy
	}
	
	protected void createSwitchObject(SceneObject sco){ // Creates a new OperatorSwitch object, based on the selected mode
		switch (mode){
			case 4: // Trains in Service mode
				operatorSwitch = new OperatorSwitch(
					getElementOnScoForName(sco, SWITCH_ELEMENT_NAME),
					coaster.getTrainCount(), // States = # of Trains on Track
					sco.getDoubleParameter("start_angle").floatValue(),
					sco.getDoubleParameter("end_angle").floatValue(),
					SWITCH_TRAVEL_TIME
				);
				break;
			case 5: // Transports mode
			case 6: // Special Track mode
			case 8: // Lights mode
			case 9: // Manual Lift Jog
				operatorSwitch = new OperatorSwitch(
					getElementOnScoForName(sco, SWITCH_ELEMENT_NAME),
					3, // States = BWD/N/FWD, Left/N/Right, or Off/Running/Emergency
					sco.getDoubleParameter("start_angle").floatValue(),
					sco.getDoubleParameter("end_angle").floatValue(),
					SWITCH_TRAVEL_TIME
				);
				break;
			default: // Every other mode just has two states
				operatorSwitch = new OperatorSwitch(
					getElementOnScoForName(sco, SWITCH_ELEMENT_NAME),
					2,
					sco.getDoubleParameter("start_angle").floatValue(),
					sco.getDoubleParameter("end_angle").floatValue(),
					SWITCH_TRAVEL_TIME
				);
		}
	}
	
	private SceneObject getScoFromParentEntity(){ // Returns the SceneObject via the parent entity ID with error handling
		SceneObject sco = sim.getSceneObjectForEntityId(getParentEntityId());
		if (sco == null){
			System.throwRuntimeException(SCRIPT_NAME + ": This script only works with NL2 scene objects");
		}
		return sco;
	}
	
	protected SceneObjectElement getElementOnScoForName(SceneObject sco, String name){ // Basically getElementForName() with error handling - Gratz to bestdani for idea
		SceneObjectElement element = sco.getElementForName(name);
		if (element == null){
			System.throwRuntimeException(SCRIPT_NAME + ": Wrong 3d model loaded (Cannot find \"" + name + "\" element)");
		}
		return element;
	}
	
	private int getModeFromScoParams(SceneObject sco){ // Returns the mode ID, based on the first MODES-based parameter to be found true
		Boolean curBool = null;
		
		for (int i = 0; i < MODES.length; i++){ // Traverse the MODES array
			if (MODES[i].equals("special_track_mode")){
				specialTrack = sco.getSpecialTrackParameter( MODES[i] );
				if (specialTrack != null) return i; else specialTrack = null;
			}
			else{
				curBool = sco.getBooleanParameter( MODES[i] );
				if (curBool != null && curBool.boolValue()) return i;
			}
		}
		return 0; // Default to static mode if no mode selection found
	}
	
	private bool isCoasterWithPlatform(Coaster coaster){ // Returns if the given coaster has a platform station, based on the master PLATFORM_COASTERS list
		int coasterID = coaster.getCoasterStyleId();
		for (int i = 0; i < PLATFORM_COASTERS.length; i++){
			if (PLATFORM_COASTERS[i] == coasterID) return true;
		}
		return false;
	}
	
	private void handleRestraintsMode(){
		if (block.getNormalModeState(Block.PROTOCOL_V1) == Block.STATE_IN_STATION){
			if (section.getTrainOnSection().getHarnessState() > binaryState){
				binaryState = section.getTrainOnSection().getHarnessState();
				operatorSwitch.setSwitchState(0);
			}
			else if (section.getTrainOnSection().getHarnessState() < binaryState){
				binaryState = section.getTrainOnSection().getHarnessState();
				operatorSwitch.setSwitchState(1);
			}
		}
	}
	
	private void handleGatesMode(){
		if (section.getStationGateState() > binaryState){
			binaryState = section.getStationGateState();
			operatorSwitch.setSwitchState(0);
		}
		else if (section.getStationGateState() < binaryState){
			binaryState = section.getStationGateState();
			operatorSwitch.setSwitchState(1);
		}
	}
	
	private void handlePlatformMode(){
		if (coasterHasPlatform){
			if (section.getStationPlatformState() > binaryState){
				binaryState = section.getStationPlatformState();
				operatorSwitch.setSwitchState(0);
			}
			else if (section.getStationPlatformState() < binaryState){
				binaryState = section.getStationPlatformState();
				operatorSwitch.setSwitchState(1);
			}
		}
	}
	
	private void handleTrainsMode(){
		trainsLashedToTrack = 1; // Set to 1 to offset the result by one, because setSwitchState() starts from 0
		for (int i = TRAIN_COUNT - 1; i >= 0; --i){ // Go through all trains
			if (coaster.getTrainAt(i).isLashedToTrack()){ // If it's lashed to track, increase the counter
				trainsLashedToTrack++;
			}
		}
		operatorSwitch.setSwitchState(TRAIN_COUNT - trainsLashedToTrack); // Set the switch state to the number of trains in service, minus 1 (for the offset)
	}
	
	private void handleTransportsMode(){
		if (block.getNormalModeState(Block.PROTOCOL_V1) == Block.STATE_FULL_MANUAL_MODE){
			float transSpeed = (float) section.getTransportCurrentSpeed();
			if (transSpeed < 0.f && transSpeed <= binaryState) operatorSwitch.setSwitchState(0);
			else if (transSpeed > 0.f && transSpeed >= binaryState) operatorSwitch.setSwitchState(2);
			else operatorSwitch.setSwitchState(1);
			binaryState = transSpeed;
		}
	}
	
	private void handleSpecialTrackMode(){
		if (specialTrack.getVisibleSwitchState() < binaryState){
			binaryState = specialTrack.getVisibleSwitchState();
			operatorSwitch.setSwitchState(0);
		}
		else if (specialTrack.getVisibleSwitchState() > binaryState){
			binaryState = specialTrack.getVisibleSwitchState();
			operatorSwitch.setSwitchState(2);
		}
		else operatorSwitch.setSwitchState(1);
	}
	
	private void handleMaintenanceMode(){
		if (block.getNormalModeState(Block.PROTOCOL_V1) == Block.STATE_FULL_MANUAL_MODE){
			operatorSwitch.setSwitchState(1);
		}
		else operatorSwitch.setSwitchState(0);
	}
	
	public void handleLightsMode(){
		if (coaster.isEmergencyStop()){
			operatorSwitch.setSwitchState(2);
		}
		else if (sim.getCurSunElevation() <= SUN_ELEVATION_LIMIT){
			operatorSwitch.setSwitchState(1);
		}
		else{
			operatorSwitch.setSwitchState(0);
		}
	}
	
	public void handleManualLiftJogMode(){
		if (block.getNormalModeState(Block.PROTOCOL_V1) == Block.STATE_FULL_MANUAL_MODE && section.isLift()){
			float liftSpeed = (float) section.getLiftCurrentSpeed();
			if (liftSpeed < 0.f && liftSpeed <= binaryState) operatorSwitch.setSwitchState(0);
			else if (liftSpeed > 0.f && liftSpeed >= binaryState) operatorSwitch.setSwitchState(2);
			else operatorSwitch.setSwitchState(1);
			binaryState = liftSpeed;
		}
	}
	
	public void onNextFrame(float tick){
		/*if (Button.isPressed(Button.FLY_SLOWER)){ //DEBUGGING
			operatorSwitch.setSwitchState(0);
		}
		if (Button.isPressed(Button.FLY_FASTER)){ //DEBUGGING
			operatorSwitch.setSwitchState(1);
		}
		if (Button.isPressed(Button.ACTION)){ //DEBUGGING
			operatorSwitch.setSwitchState(2);
		}*/
		
		switch (mode){
			case 0:
				break;
			case 1:
				handleRestraintsMode();
				break;
			case 2:
				handleGatesMode();
				break;
			case 3:
				handlePlatformMode();
				break;
			case 4:
				handleTrainsMode();
				break;
			case 5:
				handleTransportsMode();
				break;
			case 6:
				handleSpecialTrackMode();
				break;
			case 7:
				handleMaintenanceMode();
				break;
			case 8:
				handleLightsMode();
				break;
			case 9:
				handleManualLiftJogMode();
				break;
			default:
		}
		
		operatorSwitch.onNextFrame(tick); // Run switch object's onNextFrame() as well to animate
		
		if (specialTrackModule != null) specialTrackModule.setTranslation(); // If set to attach to special track, set translation of SCO
	}
}