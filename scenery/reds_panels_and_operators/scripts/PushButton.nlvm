/**
	Push Button NL2 Script
	David Wolfe (Red-Thirten)
	03/02/2024
	Animates the pilot light and button during run time, based on user settings.
	Licensed under GNU GPLv3 - See LICENSE for more details.
*/

import com.nolimitscoaster.Script;
import com.nolimitscoaster.SceneObject;
import com.nolimitscoaster.SceneObjectLight;
import com.nolimitscoaster.Coaster;
import com.nolimitscoaster.Block;
import com.nolimitscoaster.Section;
import com.nolimitscoaster.SpecialTrack;
import com.nolimitscoaster.InteractionObject;
import com.nolimitscoaster.InteractionActionListener;

import util.Logger;
import util.SceneObjectTools;
import util.OperatorButton;
import util.SpecialTrackModule;
import util.IndicatorLight;

public class PushButton extends Script implements InteractionActionListener{
	protected String SCRIPT_NAME = "PushButton";						// Script name for debugging
	protected String BUTTON_ELEMENT_NAME = "button";					// Name of the button element in the SCO/model
	protected String PLACARD_ELEMENT_NAME = "placard";					// Name of the placard element in the SCO/model
	protected String PLC_NAME = "PLC Controller";						// Name of the PLC Controller instance expected in the sim
	private static final String PLC_IND_PREFIX = "indicator";			// Prefix of the E-Stop Indicator elements & lights in the PLC SCO/model
	private static final String PLC_RESET_LIGHT_NAME = "reset_ready";	// Name of the E-Stop Reset light in the PLC SCO/model
	protected float BUTTON_TRAVEL_DIST = 0.008f;						// Distance, in meters, the button will travel to be fully "pressed"
	protected float BUTTON_TRAVEL_TIME = 1.f;							// Time, in seconds, for the button to travel in and out ("speed")
	protected float BUTTON_INTERACTION_RADIUS = 0.04f;					// Radius, in meters, of the InteractionObject detection sphere
	protected bool BUTTON_HAS_LIGHT = true;								// True if the button has a pilot light
	
	// All platform coaster IDs in NL2, as of this file's creation date
	private static final int[] PLATFORM_COASTERS = {2, 4, 6, 14, 21, 22, 24};
	// All flyer coaster IDs in NL2, as of this file's creation date
	private static final int[] FLYER_COASTERS = {18, 23};

	// All Button Modes (Functions):
	protected static final int M_STATIC_OFF = 0;
	protected static final int M_STATIC_ON = 1;
	protected static final int M_STATIC_BLINK = 2;
	protected static final int M_BLOCK_FWD = 3;
	protected static final int M_BLOCK_BWD = 4;
	protected static final int M_DISPATCH = 5;
	protected static final int M_RESTRAINTS_OPEN = 6;
	protected static final int M_RESTRAINTS_LOCK = 7;
	protected static final int M_PLATFORM_RAISE = 8;
	protected static final int M_PLATFORM_LOWER = 9;
	protected static final int M_PLATFORM_TOGGLE = 10;
	protected static final int M_SEATS_UNLOCK = 11;
	protected static final int M_SEATS_LOCK = 12;
	protected static final int M_SEATS_TOGGLE = 13;
	protected static final int M_SPECIAL_LEFT = 14;
	protected static final int M_SPECIAL_RIGHT = 15;
	protected static final int M_AUTO_DISPATCH = 16;
	protected static final int M_MANUAL_DISPATCH = 17;
	protected static final int M_AUTOMATIC_OP = 18;
	protected static final int M_SEMI_MAN_OP = 19;
	protected static final int M_FULL_MAN_OP = 20;
	protected static final int M_ESTOP_RESET = 21;
	protected static final int M_LIFT_JOG = 22;
	protected static final int M_BRAKE_RELEASE = 23;
	protected static final int M_ESTOP_SIMPLE = 24;
	protected static final int M_ESTOP_ADVANCED = 25;
	private static final int[] NON_INTERACT_MODES = {
		M_STATIC_OFF,
		M_STATIC_ON,
		M_STATIC_BLINK,
		M_LIFT_JOG,
		M_BRAKE_RELEASE
	};

	private Coaster coaster;
	private Block block;
	private Section section;
	private SpecialTrack specialTrack;
	private InteractionObject iObj;
	private SceneObjectLight plcLight;
	
	private Logger log;
	private OperatorButton button;
	private SpecialTrackModule specialTrackModule;
	private IndicatorLight plcIndicatorLight;
	
	private int mode = M_STATIC_OFF;
	private float binaryState = 0.f; // Helps determine if a "binary" state starts to change to the other value (ie. restraints start to close, vice-versa, etc)
	private bool enabled = false;
	
	public bool onInit(){ // On initialization of Play simulation
		// Get and assign local sco
		SceneObject sco = SceneObjectTools.getSceneObjectForEntityId(
			sim,
			getParentEntityId(),
			SCRIPT_NAME
		);

		// Setup Logger
		log = new Logger(SCRIPT_NAME, sco.getName());

		// Create OperatorButton object
		button = new OperatorButton(
			SceneObjectTools.getElementForName(sco, BUTTON_ELEMENT_NAME, SCRIPT_NAME),
			BUTTON_HAS_LIGHT,
			BUTTON_TRAVEL_DIST,
			BUTTON_TRAVEL_TIME
		);

		// Hide placard if configured
		if ( sco.getBooleanParameter("hide_placard").boolValue() ){
			SceneObjectTools.getElementForName(sco, PLACARD_ELEMENT_NAME, SCRIPT_NAME).setVisible(false);
		}
		
		// If set to attach to special track, set up the module object for it
		if (sco.getSpecialTrackParameter("special_track_attach") != null){
			specialTrackModule = new SpecialTrackModule(sco);
		}
		
		// Get and check configured mode
		mode = getModeFromScoParams(sco);
		if (mode > M_STATIC_BLINK){ // If not static mode
			block = sco.getBlockParameter("block");
			if (block == null){ // Check for unconfigured block
				log.err("Block parameter required for any non-static functions.");
				return false;
			}
			
			// Get ride details based on block parameter
			coaster = block.getCoaster();
			if (coaster.isScriptedOperationMode()){
				log.err("Sorry! Non-static functions do not support Scripted Operation Mode rides at this time.");
				return false;
			}
			section = block.getSection();
		}

		// Mode-specific checks and setup
		SceneObject plc = null;
		switch (mode){
			// Static modes
			case M_STATIC_OFF:
			case M_STATIC_ON:
			case M_STATIC_BLINK:
				handleStaticMode(sco);
				return false;
			// Modes that require station section
			case M_DISPATCH:
			case M_RESTRAINTS_OPEN:
			case M_RESTRAINTS_LOCK:
			case M_PLATFORM_RAISE:
			case M_PLATFORM_LOWER:
			case M_PLATFORM_TOGGLE:
			case M_SEATS_UNLOCK:
			case M_SEATS_LOCK:
			case M_SEATS_TOGGLE:
			case M_AUTO_DISPATCH:
			case M_MANUAL_DISPATCH:
				if (!section.isStation()){
					log.err("The configured function requires the specified block to be a station.");
					return false;
				}
				break;
			// Modes that require Special Track
			case M_SPECIAL_LEFT:
			case M_SPECIAL_RIGHT:
				specialTrack = sco.getSpecialTrackParameter("special_track");
				if (specialTrack == null){
					log.err("The configured function requires the Special Track parameter to be specified.");
					return false;
				}
				break;
			// Modes that require lift section
			case M_LIFT_JOG:
				if (!section.isLift()){
					log.err("The configured function requires the specified block to be a lift.");
					return false;
				}
				break;
			// Modes that require PLC Controller handle
			case M_ESTOP_ADVANCED:
			case M_ESTOP_RESET:
				SceneObject[] plcs = sim.getSceneObjectsWithName(PLC_NAME);
				for (int i = 0; i < plcs.length; i++){
					if (coaster == plcs[i].getCoasterParameter("coaster")){
						plc = plcs[i];
						break;
					}
				}
				if (plc == null){
					log.err("The configured function requires a single \"PLC Controller\" SCO to be placed and configured to control the \"" + coaster.getName() + "\" coaster.");
					return false;
				}
				if (plc.getElementForName("indicator1") == null){
					log.err("Please do not have an SCO named \"" + PLC_NAME + "\". It will conflict with the button system.");
					return false;
				}
				break;
		}

		// Check for platform (if applicable)
		switch (mode){
			case M_PLATFORM_RAISE:
			case M_PLATFORM_LOWER:
			case M_PLATFORM_TOGGLE:
				if (!isCoasterWithPlatform(coaster)){
					log.err("The configured function requires that the coaster have a platform in the station.");
					return false;
				}
		}

		// Check for flyer (if applicable)
		switch (mode){
			case M_SEATS_UNLOCK:
			case M_SEATS_LOCK:
			case M_SEATS_TOGGLE:
				if (!isCoasterFlyer(coaster)){
					log.err("The configured function requires that the coaster be a flyer coaster.");
					return false;
				}
		}

		// Register with PLC Controller if E-Stop (Advanced)
		if (mode == M_ESTOP_ADVANCED){
			for (int i = 1; i < plc.getLightCount() - 1; i++){
				SceneObjectLight curLight = SceneObjectTools.getLightForName(
					plc,
					PLC_IND_PREFIX + i,
					SCRIPT_NAME
				);
				if (curLight.isEnabled()){
					// Claim light by making IndicatorLight object (which turns it off)
					plcIndicatorLight = new IndicatorLight(
						SceneObjectTools.getElementForName(plc, PLC_IND_PREFIX + i, SCRIPT_NAME),
						curLight,
						2.f,
						true
					);
					break;
				}
			}
			if (plcIndicatorLight == null){
				log.out("Could not register with the PLC Controller because the max amount of E-Stop buttons have already been registered.");
				System.out.println("\tDefaulting to simple behavior...");
				mode = M_ESTOP_SIMPLE;
			}
		}
		// Get PLC Controller reset light handle if E-Stop Reset
		else if (mode == M_ESTOP_RESET){
			plcLight = SceneObjectTools.getLightForName(
				plc,
				PLC_RESET_LIGHT_NAME,
				SCRIPT_NAME
			);
		}

		// Setup InteractionObject (if interactible mode)
		if (isInteractibleMode(mode)){
			iObj = InteractionObject.createSimpleButton();
			iObj.setPosition(button.getAbsoluteTranslation());
			iObj.setRadius(BUTTON_INTERACTION_RADIUS);
			iObj.setProcessActionEventsWhenDisabled(true);
			iObj.addActionListener(this);
		}
		
		return true; // Everything's just dandy
	}
	
	protected int getModeFromScoParams(SceneObject sco){
		/* Get Mode from SCO Parameters
			Returns the proper mode number based on the "function" parameter enumeration.
		*/
		if (sco.getIntegerParameter("function") == null) return 0;
		
		return sco.getIntegerParameter("function").intValue();
	}

	private bool isInteractibleMode(int mode){
		for (int i = 0; i < NON_INTERACT_MODES.length; i++){
			if (mode == NON_INTERACT_MODES[i])
				return false;
		}
		return true;
	}
	
	private bool isCoasterWithPlatform(Coaster coaster){
		/* Is Coaster With Platform
			Returns if the given coaster has a platform station, based on the master PLATFORM_COASTERS list.
		*/
		int coasterID = coaster.getCoasterStyleId();
		for (int i = 0; i < PLATFORM_COASTERS.length; i++){
			if (PLATFORM_COASTERS[i] == coasterID) return true;
		}
		return false;
	}
	
	private bool isCoasterFlyer(Coaster coaster){
		/* Is Coaster Flyer
			Returns if the given coaster has flyer trains, based on the master FLYER_COASTERS list.
		*/
		int coasterID = coaster.getCoasterStyleId();
		for (int i = 0; i < FLYER_COASTERS.length; i++){
			if (FLYER_COASTERS[i] == coasterID) return true;
		}
		return false;
	}

	private void enableAction(){
		enabled = true;
		iObj.setEnabled(true);
	}
	
	private void disableAction(){
		enabled = false;
		iObj.setEnabled(false);
	}

	private void enableActionIf(bool condition){
		if (condition){
			enableAction();
		}
		else{
			disableAction();
		}
	}
	
	private void handleStaticMode(SceneObject sco){
		switch (mode){ // Sets the light's state, based on mode
			case 1:
				button.lightOn();
				break;
			case 2:
				button.lightBlink();
				break;
			default:
				button.lightOff();
		}
	}
	
	private void handleAdvanceMode(bool action){
		if (action){
			button.buttonPush();
			if (mode == M_BLOCK_FWD){
				block.doSemiManualMoveForward();
			}
			else{
				block.doSemiManualMoveBackward();
			}
			return;
		}

		bool canSemiManualMove = false;
		if ( (mode == M_BLOCK_FWD && block.canSemiManualMoveForward())
				|| (mode == M_BLOCK_BWD && block.canSemiManualMoveBackward()) ){
			canSemiManualMove = true;
		}
		// Can't Semi-Manual move
		if (coaster.isEmergencyStop() || !canSemiManualMove){
			disableAction();
			button.setLightState(Block.LAMP_OFF);
		}
		// Can Semi-Manual move
		else{
			enableAction();
			button.setLightState(block.LAMP_FLASHING);
		}
	}
	
	private void handleDispatchMode(bool action){
		if (action){
			section.doStationManualDispatch();
			return;
		}

		// Ready
		if (section.canStationManualDispatch()){
			enableActionIf(section.isStationManualDispatchMode());
			button.setLightState(Block.LAMP_FLASHING);
		}
		// Dispatching & approaching
		else if (section.isTrainOnSection() && section.getTrainOnSection().getSpeed() != 0.0){
			disableAction();
			button.setLightState(Block.LAMP_ON);
			button.buttonIn();
		}
		// Not ready
		else{
			disableAction();
			button.setLightState(Block.LAMP_OFF);
			button.buttonOut();
		}
	}
	
	private void handleRestraintsMode(bool action){
		if (action){
			if (mode == M_RESTRAINTS_OPEN){ // Restraints open
				section.doStationManualOpenHarness();
			}
			else{ // Restraints close
				section.doStationManualCloseHarness();
			}
			button.buttonPush();
			return;
		}

		if ( (mode == M_RESTRAINTS_OPEN && section.canStationManualOpenHarness())
				|| (mode == M_RESTRAINTS_LOCK && section.canStationManualCloseHarness()) ){
			enableActionIf(section.isStationManualDispatchMode());
			button.lightBlink();
		}
		else{
			disableAction();
			button.lightOn();
		}
	}
	
	private void handlePlatformMode(bool action){
		if (action){
			if (section.getStationPlatformState() == 1.f){
				section.doStationManualDisengagePlatform();
			}
			else{
				section.doStationManualEngagePlatform();
			}
			button.buttonPush();
			return;
		}

		bool canDisengage = section.canStationManualDisengagePlatform();
		bool canEngage = section.canStationManualEngagePlatform();
		// Platform moving
		if (section.getStationPlatformState() != 0.f
				&& section.getStationPlatformState() != 1.f){
			disableAction();
			button.lightOn();
		}
		// Platform ready to move
		else if ( (mode == M_PLATFORM_RAISE && canEngage)
				|| (mode == M_PLATFORM_LOWER && canDisengage)
				|| (mode == M_PLATFORM_TOGGLE && (canEngage || canDisengage)) ){
			enableActionIf(section.isStationManualDispatchMode());
			button.lightBlink();
		}
		// Platform not ready to move
		else{
			disableAction();
			button.lightOff();
		}
	}
	
	private void handleSeatsMode(bool action){
		if (action){
			if (section.isStationManualLockedSeats()){
				section.doStationManualUnlockSeats();
			}
			else{
				section.doStationManualLockSeats();
			}
			button.buttonPush();
			return;
		}
		
		bool canUnlock = section.canStationManualUnlockSeats();
		bool canLock = section.canStationManualLockSeats();
		// E-Stopped
		if (coaster.isEmergencyStop()){
			disableAction();
			button.lightOff();
		}
		// Seats moving
		else if (!section.isStationManualLockedSeats()
				&& !section.isStationManualUnlockedSeats()){
			disableAction();
			button.lightOn();
		}
		// Seats ready to move
		else if ( (mode == M_SEATS_UNLOCK && canUnlock)
				|| (mode == M_SEATS_LOCK && canLock)
				|| (mode == M_SEATS_TOGGLE && (canUnlock || canLock)) ){
			enableActionIf(section.isStationManualDispatchMode());
			button.lightBlink();
		}
		// Seats not ready to move
		else{
			disableAction();
			button.lightOff();
		}
	}

	private void handleSpecialTrackMode(bool action){
		if (action){
			int curSetPos = specialTrack.getSetSwitchDirection();
			if (mode == M_SPECIAL_LEFT){
				specialTrack.setManualSwitchDirection(
					specialTrack.getSetSwitchDirection() - 1
				);
			}
			else{
				specialTrack.setManualSwitchDirection(
					specialTrack.getSetSwitchDirection() + 1
				);
			}
			button.buttonPush();
			return;
		}
		
		// E-Stopped
		if (coaster.isEmergencyStop()){
			disableAction();
			button.lightOff();
		}
		// Track is moving
		else if (specialTrack.getVisibleSwitchState() % 1.f != 0.f){
			disableAction();
			button.lightOn();
		}
		// Track ready to move to new position
		else if ( specialTrack.canChangeManualSwitchDirection() 
				&& ( (mode == M_SPECIAL_LEFT && specialTrack.getSetSwitchDirection() - 1 > 0) 
					|| (mode == M_SPECIAL_RIGHT && specialTrack.getSetSwitchDirection() + 1 < specialTrack.getNumberOfSwitchDirections()) ) ){
			enableAction();
			button.lightBlink();
		}
		else{
			disableAction();
			button.lightOff();
		}
	}

	private void handleDispatchModeFunc(bool action){
		if (action){
			section.setStationManualDispatchMode(
				!section.isStationManualDispatchMode()
			);
			button.buttonPush();
			return;
		}
		
		if (coaster.isEmergencyStop()){
			disableAction();
			button.lightOff();
		}
		else if ( (mode == M_AUTO_DISPATCH && section.isStationManualDispatchMode())
				|| (mode == M_MANUAL_DISPATCH && !section.isStationManualDispatchMode()) ){
			enableAction();
			button.lightBlink();
		}
		else{
			disableAction();
			button.lightOn();
		}
	}
	
	private void handleBlockSystemModeFunc(bool action){
		if (action){
			switch (mode){
				case M_AUTOMATIC_OP:
					coaster.setBlockSystemMode(Coaster.E_BLOCK_SYSTEM_MODE_AUTOMATIC);
					break;
				case M_SEMI_MAN_OP:
					coaster.setBlockSystemMode(Coaster.E_BLOCK_SYSTEM_MODE_SEMI_MANUAL);
					break;
				case M_FULL_MAN_OP:
					coaster.setBlockSystemMode(Coaster.E_BLOCK_SYSTEM_MODE_FULL_MANUAL);
					break;
			}
			button.buttonPush();
			return;
		}
		
		int targetMode = 0;
		switch (mode){
			case M_AUTOMATIC_OP:
				targetMode = Coaster.E_BLOCK_SYSTEM_MODE_AUTOMATIC;
				break;
			case M_SEMI_MAN_OP:
				targetMode = Coaster.E_BLOCK_SYSTEM_MODE_SEMI_MANUAL;
				break;
			case M_FULL_MAN_OP:
				targetMode = Coaster.E_BLOCK_SYSTEM_MODE_FULL_MANUAL;
				break;
		}
		if (coaster.getBlockSystemMode() == targetMode){
			disableAction();
			button.lightOn();
		}
		else if (coaster.getBlockSystemMode() != targetMode && coaster.canSetBlockSystemMode(targetMode)){
			enableAction();
			button.lightBlink();
		}
		else{
			disableAction();
			button.lightOff();
		}
	}
	
	// E-Stop Functions //
	
	private void handleEStopSimpleMode(bool action){
		if (action){
			coaster.setEmergencyStop(!coaster.isEmergencyStop());
			return;
		}
		
		enableActionIf(coaster.canChangeEmergencyStop());
		if (coaster.isEmergencyStop()){
			button.lightOn();
			button.buttonIn();
		}
		else{
			button.lightBlink();
			button.buttonOut();
		}
	}
	
	private void handleEStopAdvancedMode(bool action){
		if (action){
			if (button.isPushedIn()){	// Pull out
				button.buttonOut();
				button.lightOff();
				plcIndicatorLight.lightOff();
			}
			else{						// Push in
				button.buttonIn();
				button.lightOn();
				plcIndicatorLight.lightOn();
			}
			disableAction();
			return;
		}
		
		enableActionIf(!button.isAnimating());
		if (!button.isPushedIn()){
			if (coaster.isEmergencyStop()){
				button.lightOff();
			}
			else{
				button.lightBlink();
			}
		}
	}
	
	private void handleEStopResetMode(bool action){
		if (action){
			button.buttonPush();
			button.lightOff();
			iObj.setEnabled(false);
			coaster.setEmergencyStop(false);
			plcLight.setEnabled(false);
			return;
		}

		if (plcLight.isEnabled() && coaster.canChangeEmergencyStop()){
			enableAction();
			button.lightBlink();
		}
		else{
			disableAction();
			button.lightOff();
		}
	}
	
	// Non-Interactible Functions //
	
	private void handleManualLiftJogMode(){
		if (block.getNormalModeState(Block.PROTOCOL_V1) != Block.STATE_FULL_MANUAL_MODE || coaster.isEmergencyStop()){
			button.lightOff();
			button.buttonOut();
		}
		else{
			float liftSpeed = (float) section.getLiftCurrentSpeed();
			if ( (liftSpeed < 0.f && liftSpeed <= binaryState) || (liftSpeed > 0.f && liftSpeed >= binaryState) ){
				button.lightOn();
				button.buttonIn();
			}
			else{
				button.lightBlink();
				button.buttonOut();
			}
			binaryState = liftSpeed;
		}
	}
	
	private void handleManualBrakeReleaseMode(){
		if (block.getNormalModeState(Block.PROTOCOL_V1) != Block.STATE_FULL_MANUAL_MODE || coaster.isEmergencyStop()){
			button.lightOff();
			button.buttonOut();
		}
		else if (!section.isBrakesOn()){
			button.lightOn();
			button.buttonIn();
		}
		else{
			button.lightBlink();
			button.buttonOut();
		}
	}

	private void handleMode(bool action){
		switch (mode){
			case M_BLOCK_FWD:
			case M_BLOCK_BWD:
				handleAdvanceMode(action);
				break;
			case M_DISPATCH:
				handleDispatchMode(action);
				break;
			case M_RESTRAINTS_OPEN:
			case M_RESTRAINTS_LOCK:
				handleRestraintsMode(action);
				break;
			case M_PLATFORM_RAISE:
			case M_PLATFORM_LOWER:
			case M_PLATFORM_TOGGLE:
				handlePlatformMode(action);
				break;
			case M_SEATS_UNLOCK:
			case M_SEATS_LOCK:
			case M_SEATS_TOGGLE:
				handleSeatsMode(action);
				break;
			case M_SPECIAL_LEFT:
			case M_SPECIAL_RIGHT:
				handleSpecialTrackMode(action);
				break;
			case M_AUTO_DISPATCH:
			case M_MANUAL_DISPATCH:
				handleDispatchModeFunc(action);
				break;
			case M_AUTOMATIC_OP:
			case M_SEMI_MAN_OP:
			case M_FULL_MAN_OP:
				handleBlockSystemModeFunc(action);
				break;
			case M_ESTOP_SIMPLE:
				handleEStopSimpleMode(action);
				break;
			case M_ESTOP_ADVANCED:
				handleEStopAdvancedMode(action);
				break;
			case M_ESTOP_RESET:
				handleEStopResetMode(action);
				break;
			case M_LIFT_JOG:
				handleManualLiftJogMode();
				break;
			case M_BRAKE_RELEASE:
				handleManualBrakeReleaseMode();
				break;
		}
	}

	public void onNextFrame(float tick){
		/*if (Button.isPressed(Button.ACTION)){ //DEBUGGING
			button.buttonIn();
		}
		if (Button.isPressed(Button.FLY_SLOWER)){ //DEBUGGING
			button.buttonOut();
		}*/
		handleMode(false);
		
		// Run button object's onNextFrame() as well to animate
		button.onNextFrame(tick);
		
		// If set to attach to special track, set translation of SCO
		if (specialTrackModule != null) specialTrackModule.setTranslation();
	}

	public void onInteractionAction(InteractionObject obj){
		if (enabled){
			handleMode(true);
		}
		else{
			button.buttonPush();
		}
	}
}